#include <rpc/types.h>
#include <rpc/xdr.h>
#include <string>
#include "shaders.h"
const std::string fluxShader::VERTEX_SHADER_SRC = 
"//particle shader\n"
"//convert the particles to point sprite\n"
"/*input postion and parameter of exactly a particle*/\n"
"/*outout: xc, yc, r, dtheta, */\n"
"\n"
"\n"
"//the new coordinate system based on the vpos\n"
"#define PI 3.1415926535897932\n"
"#define e32 4.4816890703380648226           //e^(3/2)\n"
"\n"
"uniform mat3 rotmatrix; //rotation matrix\n"
"uniform vec3 opos;\n"
"uniform vec3 geofac; //geometry fact{size(square),viewportsize, maxpointsize }\n"
"\n"
"//uniform float sdthetha;\n"
"\n"
"varying vec4 particle;    //the radius of the particle circle and the coordianate\n"
"        //size, x, y, z\n"
"\n"
"uniform int usenormmap;    //whether use the norm map? true: 1 else:0\n"
"            \n"
"\n"
"//This is very important, must be checked\n"
"float profile(vec3 r1,float dtheta){\n"
"    vec3 r0 = vec3(particle.gba);\n"
"    float costheta = dot(r0, r1)/(length(r0)*length(r1));\n"
"    //use tylor seriers\n"
"    //acos has too much error\n"
"    costheta = clamp(costheta, -1.0, 1.0);\n"
"    float t2 = 2.0 * ( 1.0 - costheta) + 1.0/3.0*(costheta - 1.0)*(costheta - 1.0) - 4.0/45.0 * (costheta - 1.0) *(costheta - 1.0)*(costheta - 1.0);\n"
"    //costheta = clamp(costheta, -1.0, 1.0);\n"
"    //float t2 = acos(costheta);\n"
"    //t2 = t2*t2;\n"
"   \n"
"    float d2 = clamp(t2 / dtheta / dtheta, 0.0, 1.0);\n"
"    //float d2 = clamp(t2 / dtheta / dtheta, 0.0, 1.0);\n"
"    \n"
"    if(t2 > 1.0){\n"
"        return 0.0;\n"
"    }\n"
"    if(t2 < 0.0){\n"
"        t2 = 0.0;\n"
"    }\n"
"    return exp(- 1.5 * d2);         //here comes the problems\n"
"    //return 1.0 - 1.5 * d2;\n"
"    \n"
"}\n"
"\n"
"//reverse stereoprojection\n"
"vec3 prev(vec2 xy){\n"
"    float r2 = xy.x*xy.x + xy.y*xy.y;\n"
"    return vec3(2.0 * xy.x/(1.0 + r2), 2.0 * xy.y/(1.0 + r2), (r2 - 1.0)/(r2 + 1.0));\n"
"}\n"
"\n"
"\n"
"float calc_norm(vec2 svec, float newsize, float dtheta){\n"
"    float norm = 0.0;\n"
"    \n"
"    vec2 coor = svec * geofac.y / 2.0;\n"
"    \n"
"    \n"
"    float x=0.0;\n"
"    float y=0.0;\n"
"    for(x = 0.0; x < newsize; x++){\n"
"        for(y = 0.0; y < newsize; y++){\n"
"            float px = (x+0.5)/newsize;\n"
"            float py = (y+0.5)/newsize;\n"
"            px = 2.0*(px-0.5); // -1...1\n"
"            py = 2.0*(py-0.5);\n"
"            vec2 xy = vec2(px, py);\n"
"            float u = dot(xy, xy);\n"
"            if (u > 1.0)\n"
"                continue;\n"
"            \n"
"            vec2 xyp = xy * (newsize / 2.0) + coor;\n"
"            vec2 xyr = xyp / (geofac.y / 2.0);\n"
"            float pr2 = dot(xyr, xyr);\n"
"            norm += 4.0/(1.0+pr2)/(1.0+pr2) * profile(prev(xyr), dtheta);\n"
"            //norm += 1.0;\n"
"            \n"
"        }\n"
"    }\n"
"    return 1.0/norm;\n"
"    //return 1.0 / (newsize * newsize);\n"
"}\n"
"\n"
"float calc_norm1(float theta0){\n"
"    return 2.0*(-1.0 + e32) * PI * theta0 * theta0 / (3.0 * e32) -\n"
"        (PI * (-5.0 + 2.0 * e32) * theta0 * theta0 * theta0 * theta0) / (27.0 * e32)\n"
"        +(PI * (-29.0 + 8.0 * e32) * PI * theta0 * theta0 * theta0 * theta0 * theta0 * theta0) / ( 1620.0 * e32);\n"
"}\n"
"\n"
"void main(){\n"
"/*    gl_PointSize = 100.0;\n"
"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"    gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"    gl_FrontColor = vec4(xaxis.x,yaxis.y, zaxis.z,0);*/\n"
"    \n"
"    vec4 newpos;\n"
"   //find the angle\n"
"    vec3 pvec = vec3(gl_Vertex) - opos;    \n"
"                                        //input x, y z of the particle\n"
"                                        //transform it to the stereoprojection plane\n"
"    vec4 parameter = vec4(gl_Color);    //parameters\n"
"                                        //mass, density and hsmooth\n"
"    \n"
"    float dtheta;                       //anular radias\n"
"    //float phi;\n"
"    float dsize;\n"
" \n"
"    \n"
"    float distance = length(pvec);\n"
"    \n"
"    \n"
"    dtheta = parameter.b / distance;    //2.186\n"
"    \n"
"    //rotation and normalize\n"
"    vec3 npvec = normalize(rotmatrix * pvec);\n"
"    \n"
"    \n"
"    float costheta = clamp(npvec.z, -1.0, 1.0);//dot(npvec, nzaxis);\n"
"    //costheta -3.0 / 5.0;\n"
"    float theta = acos(costheta);      //0.955\n"
"    \n"
"    //vec3 newpvec = vec3(dot(npvec, nxaxis), dot(npvec, nyaxis),costheta);\n"
"    \n"
"    if((theta > PI / 2.0 || theta + dtheta >= PI / 2.0) && dtheta < PI / 2.0)\n"
"    {\n"
"        float sintheta = sin(theta);\n"
"        float sinphi;\n"
"        float cosphi;\n"
"        if(sintheta < 1.0e-8 ){\n"
"            //phi = 0.0;\n"
"            sinphi = 0.0;\n"
"            cosphi = 1.0;\n"
"        }else{\n"
"            sinphi = npvec.y/sintheta;//newpvec.y / sintheta;\n"
"            cosphi = npvec.x/sintheta;//newpvec.x / sintheta;\n"
"        }\n"
"        \n"
"        //phi= PI / 2.0;\n"
"        \n"
"        float flux = parameter.g * parameter.r / (4.0 * PI * distance * distance);\n"
"    \n"
"    \n"
"        float xc, yc, r;\n"
"    \n"
"        //transform the vertex:\n"
"        //stereoproject a circle\n"
"        float sintpr = sin(theta + dtheta);\n"
"        float costpr = cos(theta + dtheta);\n"
"        float sintmr = sin(theta - dtheta);\n"
"        float costmr = cos(theta - dtheta);\n"
"        float a = sintpr/(1.0-costpr);\n"
"        float b = sintmr/(1.0-costmr);\n"
"        r = -(a - b)/2.0;\n"
"        float prho = (a + b)/2.0;\n"
"        xc = prho * cosphi;\n"
"        yc = prho * sinphi;\n"
"        float newsize = floor(r *geofac.y); ///!!!!!!!!!!!!!!!!\n"
"\n"
"        \n"
"        newpos = vec4(xc * geofac.x, yc * geofac.x, 0.0, 1.0);\n"
"        \n"
"        if(newsize > geofac.z){\n"
"            dsize = geofac.z / newsize * r;\n"
"            newsize = geofac.z;\n"
"        }else{\n"
"            dsize = r;\n"
"        }\n"
"        \n"
"        if(newsize < 1.0){\n"
"            newsize = 1.0;\n"
"        }\n"
"        gl_PointSize = newsize;  //point size\n"
"    \n"
"\n"
"        //calculate normfac\n"
"        //particle must be written before fhe nomal fac\n"
"        //particle = vec4(dsize, npvec.x, npvec.y, npvec.z);\n"
"        particle = vec4(newsize, npvec.x, npvec.y, npvec.z);\n"
"        \n"
"        float normfac;\n"
"        float d2 = dtheta * dtheta;\n"
"        {\n"
"            if(usenormmap == 0 && newsize != 1.0){\n"
"                //use actual norm\n"
"                normfac = calc_norm(vec2(xc, yc), newsize, dtheta);\n"
"                //use analytical norm\n"
"				//normfac = 1.0 / (geofac.y * geofac.y) / calc_norm1(dtheta) * 4.0;\n"
"            }else{\n"
"                normfac = 1.0;\n"
"            }\n"
"        }\n"
"        \n"
"        //Must add another vector (xc, yc)\n"
"        //flux = 1.0;\n"
"        gl_FrontColor = vec4(xc, yc, flux * normfac , dtheta);\n"
"\n"
"        gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"    }else{\n"
"        gl_PointSize = 1.0;  //point size\n"
"        newpos = vec4(0.0, 0.0, 0.0, 1.0);\n"
"        gl_FrontColor = vec4(0, 0, 0, 0);\n"
"        gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"    }\n"
"    //newpos = vec4(-3,-3, 0, 1);\n"
"    //gl_PointSize = 200.0;  //point size\n"
"    gl_Position = gl_ModelViewProjectionMatrix * newpos;    \n"
"    gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"    //gl_FrontColor = vec4(dtheta,0,0,1);\n"
"    //dsize = 0.4;\n"
"    \n"
"}\n"
;

const std::string fluxShader::FRAGMENT_SHADER_SRC = 
"//draw projected gaussian profile\n"
"\n"
"#define PI 3.1415926535897932\n"
"uniform vec3 geofac;\n"
"            //orthsize, windowsize, pointsize\n"
"\n"
"varying vec4 particle;\n"
"uniform sampler2D normmap;\n"
"uniform int usenormmap;    //whether use the norm map? true: 1 else:0\n"
"\n"
"\n"
"//This is very important, must be checked \n"
"float profile(vec3 r1,float dtheta){ \n"
"    vec3 r0 = vec3(particle.gba);\n"
"    float costheta = dot(r0, r1)/(length(r0)*length(r1));\n"
"    //use tylor seriers\n"
"    //acos has too much error\n"
"    costheta = clamp(costheta, -1.0, 1.0);\n"
"    float t2 = 2.0 * ( 1.0 - costheta) + 1.0/3.0*(costheta - 1.0)*(costheta - 1.0) - 4.0/45.0 * (costheta - 1.0) *(costheta - 1.0)*(costheta - 1.0);\n"
"    //costheta = clamp(costheta, -1.0, 1.0);\n"
"    //float t2 = acos(costheta);\n"
"    //t2 = t2*t2;\n"
"    float d2 = clamp(t2 / dtheta / dtheta, 0.0, 1.0);\n"
"    //float d2 = (t2 / dtheta / dtheta, 0.0, 1.0);\n"
"    \n"
"    if(t2 > 1.0){\n"
"        return 0.0;\n"
"    }\n"
"    if(t2 < 0.0){\n"
"        t2 = 0.0;\n"
"    }\n"
"    return exp(- 1.5 * d2);         //here comes the problems\n"
"    //return 1.0 - 1.5 * d2;\n"
"    \n"
"}\n"
"\n"
"//reverse stereoprojection\n"
"vec3 prev(vec2 xy){\n"
"    float r2 = xy.x*xy.x + xy.y*xy.y;\n"
"    return vec3(2.0 * xy.x/(1.0 + r2), 2.0 * xy.y/(1.0 + r2), (r2 - 1.0)/(r2 + 1.0));\n"
"}\n"
"\n"
"float projprofile(vec2 xy, float fc, float dtheta){\n"
"    return fc * profile(prev(xy), dtheta);\n"
"}\n"
"\n"
"\n"
"\n"
"void main(){\n"
"    //float dsize = particle.r;\n"
"    float newsize = particle.r;\n"
"    vec2 xyc = gl_Color.rg;\n"
"    vec2 coor = xyc *geofac.y / 2.0;\n"
"    float flux = 0.0;\n"
"    float fluxfac = gl_Color.b;\n"
"	if(newsize != 1.0){\n"
"		if(fluxfac != 0.0){\n"
"			float dtheta = gl_Color.a;\n"
"			vec2 p = floor(newsize * vec2(gl_TexCoord[0].s,gl_TexCoord[0].t));\n"
"			\n"
"			p = (p+0.5) / newsize;\n"
"			p = 2.0*(p-0.5);\n"
"			float u = dot(p, p);\n"
"			if (u > 1.0) discard;\n"
"			\n"
"			vec2 xyp = p * (newsize / 2.0) + coor;\n"
"			vec2 xyr = xyp / (geofac.y / 2.0);\n"
"			float pr2 = dot(xyr, xyr);\n"
"            //use the actual norm\n"
"			flux = fluxfac  * profile(prev(xyr), dtheta) * 4.0/(1.0+pr2)/(1.0+pr2);\n"
"            //use analytical norm\n"
"            //flux = fluxfac  * profile(prev(xyr), dtheta) * 4.0/(1.0+pr2)/(1.0+pr2);\n"
"			//flux = fluxfac;\n"
"			if(usenormmap == 1){\n"
"				float r0 = sqrt(pr2);\n"
"				float r = newsize / geofac.z;\n"
"				float norm = (texture2D(normmap, vec2(r0, r))).r;\n"
"				//if(norm < 0.0) norm = 1.0;\n"
"				flux = flux / norm;\n"
"			}\n"
"			\n"
"\n"
"			gl_FragColor = vec4(flux, 0, 0, 1.0);\n"
"		}else{\n"
"			discard;\n"
"		}\n"
"	}else{\n"
"		gl_FragColor = vec4(fluxfac, 0, 0, 1.0);\n"
"	}\n"
"}\n"
;
